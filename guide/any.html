<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>any 类型，unknown 类型，never 类型 | Typescript 教程</title><meta name="description" content="阮一峰《Typescript 教程》">
    <link rel="preload" href="/typescript-tutorial/assets/style-By2UttZl.css" as="style"><link rel="stylesheet" href="/typescript-tutorial/assets/style-By2UttZl.css">
    <link rel="modulepreload" href="/typescript-tutorial/assets/app-CP2N477c.js"><link rel="modulepreload" href="/typescript-tutorial/assets/any.html-xJGqKz26.js">
    <link rel="prefetch" href="/typescript-tutorial/assets/index.html-CCjmKKHz.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/get-started.html-75MrMa_W.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/array.html-D4i5rKC3.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/assert.html-BgvWcwPO.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/basic.html-tXa2yO3t.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/class.html-B9v-Pfzu.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/comment.html-Ch4wYEYz.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/d.ts.html-PvK2BjLm.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/declare.html-BgDVQjej.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/decorator-legacy.html-CRROLvoQ.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/decorator.html-ByJiJzjk.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/enum.html-Bcc7pYJY.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/es6.html-C4lWP4TH.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/function.html-BN4fq0oO.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/generics.html-CfrisSeC.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/interface.html-DnXom_gM.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/intro.html-DIklPSrg.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/mapping.html-CyreZkXo.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/module.html-CNaSFg7a.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/namespace.html-DuUEMthv.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/narrowing.html-BuXK3gN3.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/npm.html-Bj6eZfxt.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/object.html-PFunvCRT.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/operator.html-hZ5BsSoH.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/react.html-BvgWKWeC.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/symbol.html-D08-DIgl.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/tsc.html-C3LG69-I.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/tsconfig.json.html-DandD4Y4.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/tuple.html-c9OTNCSu.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/type-operations.html-CpaxAplI.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/types.html-C4Z4jhcm.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/utility.html-C9oaUynG.js" as="script"><link rel="prefetch" href="/typescript-tutorial/assets/404.html-Dg7KsDsd.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/typescript-tutorial/"><img class="vp-site-logo" src="https://vuejs.press/images/hero.png" alt="Typescript 教程"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Typescript 教程</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/typescript-tutorial/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/typescript-tutorial/guide/intro.html" aria-label="全文阅读"><!--[--><!--[--><!--]--><!--]-->全文阅读<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://mmmying.github.io/how-browsers-work/" aria-label="浏览器工作原理" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->浏览器工作原理<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://mmmying.github.io/" aria-label="我的博客" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->我的博客<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/typescript-tutorial/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/typescript-tutorial/guide/intro.html" aria-label="全文阅读"><!--[--><!--[--><!--]--><!--]-->全文阅读<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://mmmying.github.io/how-browsers-work/" aria-label="浏览器工作原理" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->浏览器工作原理<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://mmmying.github.io/" aria-label="我的博客" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->我的博客<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/intro.html" aria-label="1. 简介"><!--[--><!--[--><!--]--><!--]-->1. 简介<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/basic.html" aria-label="2. 基本用法"><!--[--><!--[--><!--]--><!--]-->2. 基本用法<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item vp-sidebar-heading active" href="/typescript-tutorial/guide/any.html" aria-label="3. any 类型"><!--[--><!--[--><!--]--><!--]-->3. any 类型<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/types.html" aria-label="4. 类型系统"><!--[--><!--[--><!--]--><!--]-->4. 类型系统<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/array.html" aria-label="5. 数组"><!--[--><!--[--><!--]--><!--]-->5. 数组<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/tuple.html" aria-label="6. 元组"><!--[--><!--[--><!--]--><!--]-->6. 元组<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/symbol.html" aria-label="7. symbol 类型"><!--[--><!--[--><!--]--><!--]-->7. symbol 类型<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/function.html" aria-label="8. 函数"><!--[--><!--[--><!--]--><!--]-->8. 函数<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/object.html" aria-label="9. 对象"><!--[--><!--[--><!--]--><!--]-->9. 对象<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/interface.html" aria-label="10. interface"><!--[--><!--[--><!--]--><!--]-->10. interface<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/class.html" aria-label="11. 类"><!--[--><!--[--><!--]--><!--]-->11. 类<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/generics.html" aria-label="12. 泛型"><!--[--><!--[--><!--]--><!--]-->12. 泛型<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/enum.html" aria-label="13. Enum 类型"><!--[--><!--[--><!--]--><!--]-->13. Enum 类型<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/assert.html" aria-label="14. 类型断言"><!--[--><!--[--><!--]--><!--]-->14. 类型断言<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/module.html" aria-label="15. 模块"><!--[--><!--[--><!--]--><!--]-->15. 模块<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/namespace.html" aria-label="16. namespace"><!--[--><!--[--><!--]--><!--]-->16. namespace<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/decorator.html" aria-label="17. 装饰器"><!--[--><!--[--><!--]--><!--]-->17. 装饰器<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/decorator-legacy.html" aria-label="18. 装饰器（旧语法）"><!--[--><!--[--><!--]--><!--]-->18. 装饰器（旧语法）<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/declare.html" aria-label="19. declare 关键字"><!--[--><!--[--><!--]--><!--]-->19. declare 关键字<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/d.ts.html" aria-label="20. d.ts 类型声明文件"><!--[--><!--[--><!--]--><!--]-->20. d.ts 类型声明文件<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/operator.html" aria-label="21. 类型运算符"><!--[--><!--[--><!--]--><!--]-->21. 类型运算符<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/mapping.html" aria-label="22. 类型映射"><!--[--><!--[--><!--]--><!--]-->22. 类型映射<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/utility.html" aria-label="23. 类型工具"><!--[--><!--[--><!--]--><!--]-->23. 类型工具<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/comment.html" aria-label="24. 注释指令"><!--[--><!--[--><!--]--><!--]-->24. 注释指令<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/tsconfig.json.html" aria-label="25. tsconfig.json 文件"><!--[--><!--[--><!--]--><!--]-->25. tsconfig.json 文件<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/typescript-tutorial/guide/tsc.html" aria-label="26. tsc 命令"><!--[--><!--[--><!--]--><!--]-->26. tsc 命令<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="any-类型-unknown-类型-never-类型" tabindex="-1"><a class="header-anchor" href="#any-类型-unknown-类型-never-类型"><span>any 类型，unknown 类型，never 类型</span></a></h1><p>本章介绍 TypeScript 的三种特殊类型，它们可以作为学习 TypeScript 类型系统的起点。</p><h2 id="any-类型" tabindex="-1"><a class="header-anchor" href="#any-类型"><span>any 类型</span></a></h2><h3 id="基本含义" tabindex="-1"><a class="header-anchor" href="#基本含义"><span>基本含义</span></a></h3><p>any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">any</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span></span>
<span class="line">x <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span></span>
<span class="line">x <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>的类型是<code>any</code>，就可以被赋值为任意类型的值。</p><p>变量类型一旦设为<code>any</code>，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 不报错</span></span>
<span class="line">x<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 不报错</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>的值是一个字符串，但是把它当作函数调用，或者当作对象读取任意属性，TypeScript 编译时都不报错。原因就是<code>x</code>的类型是<code>any</code>，TypeScript 不对其进行类型检查。</p><p>由于这个原因，应该尽量避免使用<code>any</code>类型，否则就失去了使用 TypeScript 的意义。</p><p>实际开发中，<code>any</code>类型主要适用以下两个场合。</p><p>（1）出于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为<code>any</code>。</p><p>（2）为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为<code>any</code>。有些年代很久的大型 JavaScript 项目，尤其是别人的代码，很难为每一行适配正确的类型，这时你为那些类型复杂的变量加上<code>any</code>，TypeScript 编译时就不会报错。</p><p>总之，TypeScript 认为，只要开发者使用了<code>any</code>类型，就表示开发者想要自己来处理这些代码，所以就不对<code>any</code>类型进行任何限制，怎么使用都可以。</p><p>从集合论的角度看，<code>any</code>类型可以看成是所有其他类型的全集，包含了一切可能的类型。TypeScript 将这种类型称为“顶层类型”（top type），意为涵盖了所有下层。</p><h3 id="类型推断问题" tabindex="-1"><a class="header-anchor" href="#类型推断问题"><span>类型推断问题</span></a></h3><p>对于开发者没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是<code>any</code>。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 不报错</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>add()</code>的参数变量<code>x</code>和<code>y</code>，都没有足够的信息，TypeScript 无法推断出它们的类型，就会认为这两个变量和函数返回值的类型都是<code>any</code>。以至于后面就不再对函数<code>add()</code>进行类型检查了，怎么用都可以。</p><p>这显然是很糟糕的情况，所以对于那些类型不明显的变量，一定要显式声明类型，防止被推断为<code>any</code>。</p><p>TypeScript 提供了一个编译选项<code>noImplicitAny</code>，打开该选项，只要推断出<code>any</code>类型就会报错。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line">$ tsc <span class="token parameter variable">--noImplicitAny</span> app.ts</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面命令使用了<code>noImplicitAny</code>编译选项进行编译，这时上面的函数<code>add()</code>就会报错。</p><p>这里有一个特殊情况，即使打开了<code>noImplicitAny</code>，使用<code>let</code>和<code>var</code>命令声明变量，但不赋值也不指定类型，是不会报错的。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">var</span> x<span class="token punctuation">;</span> <span class="token comment">// 不报错</span></span>
<span class="line"><span class="token keyword">let</span> y<span class="token punctuation">;</span> <span class="token comment">// 不报错</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>和<code>y</code>声明时没有赋值，也没有指定类型，TypeScript 会推断它们的类型为<code>any</code>。这时即使打开了<code>noImplicitAny</code>，也不会报错。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> x<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">x <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>
<span class="line">x <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>的类型推断为<code>any</code>，但是不报错，可以顺利通过编译。</p><p>由于这个原因，建议使用<code>let</code>和<code>var</code>声明变量时，如果不赋值，就一定要显式声明类型，否则可能存在安全隐患。</p><p><code>const</code>命令没有这个问题，因为 JavaScript 语言规定<code>const</code>声明变量时，必须同时进行初始化（赋值）。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">const</span> x<span class="token punctuation">;</span> <span class="token comment">// 报错</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面示例中，<code>const</code>命令声明的<code>x</code>是不能改变值的，声明时必须同时赋值，否则报错，所以它不存在类型推断为<code>any</code>的问题。</p><h3 id="污染问题" tabindex="-1"><a class="header-anchor" href="#污染问题"><span>污染问题</span></a></h3><p><code>any</code>类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">let</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 不报错</span></span>
<span class="line"></span>
<span class="line">y <span class="token operator">*</span> <span class="token number">123</span> <span class="token comment">// 不报错</span></span>
<span class="line">y<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 不报错</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>的类型是<code>any</code>，实际的值是一个字符串。变量<code>y</code>的类型是<code>number</code>，表示这是一个数值变量，但是它被赋值为<code>x</code>，这时并不会报错。然后，变量<code>y</code>继续进行各种数值运算，TypeScript 也检查不出错误，问题就这样留到运行时才会暴露。</p><p>污染其他具有正确类型的变量，把错误留到运行时，这就是不宜使用<code>any</code>类型的另一个主要原因。</p><h2 id="unknown-类型" tabindex="-1"><a class="header-anchor" href="#unknown-类型"><span>unknown 类型</span></a></h2><p>为了解决<code>any</code>类型“污染”其他变量的问题，TypeScript 3.0 引入了<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type" target="_blank" rel="noopener noreferrer"><code>unknown</code>类型</a>。它与<code>any</code>含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像<code>any</code>那样自由，可以视为严格版的<code>any</code>。</p><p><code>unknown</code>跟<code>any</code>的相似之处，在于所有类型的值都可以分配给<code>unknown</code>类型。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">unknown</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">x <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span></span>
<span class="line">x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span></span>
<span class="line">x <span class="token operator">=</span> <span class="token string">&#39;Hello World&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>的类型是<code>unknown</code>，可以赋值为各种类型的值。这与<code>any</code>的行为一致。</p><p><code>unknown</code>类型跟<code>any</code>类型的不同之处在于，它不能直接使用。主要有以下几个限制。</p><p>首先，<code>unknown</code>类型的变量，不能直接赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> v<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> v1<span class="token operator">:</span><span class="token builtin">boolean</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">// 报错</span></span>
<span class="line"><span class="token keyword">let</span> v2<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">// 报错</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>v</code>是<code>unknown</code>类型，赋值给<code>any</code>和<code>unknown</code>以外类型的变量都会报错，这就避免了污染问题，从而克服了<code>any</code>类型的一大缺点。</p><p>其次，不能直接调用<code>unknown</code>类型变量的方法和属性。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> v1<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">v1<span class="token punctuation">.</span>foo  <span class="token comment">// 报错</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> v2<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 报错</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> v3<span class="token operator">:</span><span class="token function-variable function">unknown</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token function">v3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 报错</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，直接调用<code>unknown</code>类型变量的属性和方法，或者直接当作函数执行，都会报错。</p><p>再次，<code>unknown</code>类型变量能够进行的运算是有限的，只能进行比较运算（运算符<code>==</code>、<code>===</code>、<code>!=</code>、<code>!==</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code>）、取反运算（运算符<code>!</code>）、<code>typeof</code>运算符和<code>instanceof</code>运算符这几种，其他运算都会报错。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> a<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">a <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">// 报错</span></span>
<span class="line">a <span class="token operator">===</span> <span class="token number">1</span> <span class="token comment">// 正确</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>unknown</code>类型的变量<code>a</code>进行加法运算会报错，因为这是不允许的运算。但是，进行比较运算就是可以的。</p><p>那么，怎么才能使用<code>unknown</code>类型变量呢？</p><p>答案是只有经过“类型缩小”，<code>unknown</code>类型变量才可以使用。所谓“类型缩小”，就是缩小<code>unknown</code>变量的类型范围，确保不会出错。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> a<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> a <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">let</span> r <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>unknown</code>类型的变量<code>a</code>经过<code>typeof</code>运算以后，能够确定实际类型是<code>number</code>，就能用于加法运算了。这就是“类型缩小”，即将一个不确定的类型缩小为更明确的类型。</p><p>下面是另一个例子。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> s<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> s <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 正确</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，确定变量<code>s</code>的类型为字符串以后，才能调用它的<code>length</code>属性。</p><p>这样设计的目的是，只有明确<code>unknown</code>变量的实际类型，才允许使用它，防止像<code>any</code>那样可以随意乱用，“污染”其他变量。类型缩小以后再使用，就不会报错。</p><p>总之，<code>unknown</code>可以看作是更安全的<code>any</code>。一般来说，凡是需要设为<code>any</code>类型的地方，通常都应该优先考虑设为<code>unknown</code>类型。</p><p>在集合论上，<code>unknown</code>也可以视为所有其他类型（除了<code>any</code>）的全集，所以它和<code>any</code>一样，也属于 TypeScript 的顶层类型。</p><h2 id="never-类型" tabindex="-1"><a class="header-anchor" href="#never-类型"><span>never 类型</span></a></h2><p>为了保持与集合论的对应关系，以及类型运算的完整性，TypeScript 还引入了“空类型”的概念，即该类型为空，不包含任何值。</p><p>由于不存在任何属于“空类型”的值，所以该类型被称为<code>never</code>，即不可能有这样的值。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">never</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>的类型是<code>never</code>，就不可能赋给它任何值，否则都会报错。</p><p><code>never</code>类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性，详见后面章节。另外，不可能返回值的函数，返回值的类型就可以写成<code>never</code>，详见《函数》一章。</p><p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。这时，处理所有可能的类型之后，剩余的情况就属于<code>never</code>类型。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">string</span><span class="token operator">|</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    x<span class="token punctuation">;</span> <span class="token comment">// never 类型</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数变量<code>x</code>可能是字符串，也可能是数值，判断了这两种情况后，剩下的最后那个<code>else</code>分支里面，<code>x</code>就是<code>never</code>类型了。</p><p><code>never</code>类型的一个重要特点是，可以赋值给任意其他类型。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">never</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;Error&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> v1<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不报错</span></span>
<span class="line"><span class="token keyword">let</span> v2<span class="token operator">:</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不报错</span></span>
<span class="line"><span class="token keyword">let</span> v3<span class="token operator">:</span><span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不报错</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>f()</code>会抛出错误，所以返回值类型可以写成<code>never</code>，即不可能返回任何值。各种其他类型的变量都可以赋值为<code>f()</code>的运行结果（<code>never</code>类型）。</p><p>为什么<code>never</code>类型可以赋值给任意其他类型呢？这也跟集合论有关，空集是任何集合的子集。TypeScript 就相应规定，任何类型都包含了<code>never</code>类型。因此，<code>never</code>类型是任何其他类型所共有的，TypeScript 把这种情况称为“底层类型”（bottom type）。</p><p>总之，TypeScript 有两个“顶层类型”（<code>any</code>和<code>unknown</code>），但是“底层类型”只有<code>never</code>唯一一个。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 987042638@qq.com">mmmying</span><!----><!--]--><!--]--></span></div></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/typescript-tutorial/guide/basic.html" aria-label="2. 基本用法"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span class="external-link">2. 基本用法</span></div><!--]--></a><a class="route-link auto-link next" href="/typescript-tutorial/guide/types.html" aria-label="4. 类型系统"><!--[--><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span class="external-link">4. 类型系统</span></div><!--]--></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/typescript-tutorial/assets/app-CP2N477c.js" defer></script>
  </body>
</html>
